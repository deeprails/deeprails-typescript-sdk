// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { maybeFilter } from 'deeprails-mcp/filtering';
import { Metadata, asTextContentResult } from 'deeprails-mcp/tools/types';

import { Tool } from '@modelcontextprotocol/sdk/types.js';
import Deeprails from 'deeprails';

export const metadata: Metadata = {
  resource: 'monitor',
  operation: 'write',
  tags: [],
  httpMethod: 'post',
  httpPath: '/monitor/{monitor_id}/events',
};

export const tool: Tool = {
  name: 'submit_event_monitor',
  description:
    "When using this tool, always use the `jq_filter` parameter to reduce the response size and improve performance.\n\nOnly omit if you're sure you don't need the data.\n\nSubmit a model input and output pair to a monitor for evaluation.\n\n# Response Schema\n```json\n{\n  type: 'object',\n  description: 'Response wrapper for operations returning a MonitorEventResponse.',\n  properties: {\n    success: {\n      type: 'boolean',\n      description: 'Represents whether the request was completed successfully.'\n    },\n    data: {\n      type: 'object',\n      description: 'Response payload for monitor event operations.',\n      properties: {\n        evaluation_id: {\n          type: 'string',\n          description: 'A unique evaluation ID associated with this event.'\n        },\n        event_id: {\n          type: 'string',\n          description: 'A unique monitor event ID.'\n        },\n        monitor_id: {\n          type: 'string',\n          description: 'Monitor ID associated with this event.'\n        },\n        created_at: {\n          type: 'string',\n          description: 'The time the monitor event was created in UTC.',\n          format: 'date-time'\n        }\n      },\n      required: [        'evaluation_id',\n        'event_id',\n        'monitor_id'\n      ]\n    },\n    message: {\n      type: 'string',\n      description: 'The accompanying message for the request.  Includes error details when applicable.'\n    }\n  },\n  required: [    'success'\n  ]\n}\n```",
  inputSchema: {
    type: 'object',
    properties: {
      monitor_id: {
        type: 'string',
      },
      guardrail_metrics: {
        type: 'array',
        description:
          'An array of guardrail metrics that the model input and output pair will be evaluated on.  For non-enterprise users, these will be limited to `correctness`, `completeness`, `instruction_adherence`, `context_adherence`, `ground_truth_adherence`, and/or `comprehensive_safety`.\n',
        items: {
          type: 'string',
          enum: [
            'correctness',
            'completeness',
            'instruction_adherence',
            'context_adherence',
            'ground_truth_adherence',
            'comprehensive_safety',
          ],
        },
      },
      model_input: {
        type: 'object',
        description:
          'A dictionary of inputs sent to the LLM to generate output.  This must contain a `user_prompt` field and an optional `context` field.  Additional properties are allowed.\n',
        properties: {
          user_prompt: {
            type: 'string',
          },
          context: {
            type: 'string',
          },
        },
        required: ['user_prompt'],
      },
      model_output: {
        type: 'string',
        description: 'Output generated by the LLM to be evaluated.',
      },
      model_used: {
        type: 'string',
        description: 'Model ID used to generate the output, like `gpt-4o` or `o3`.',
      },
      nametag: {
        type: 'string',
        description: 'An optional, user-defined tag for the event.',
      },
      run_mode: {
        type: 'string',
        description:
          'Run mode for the monitor event.  The run mode allows the user to optimize for speed, accuracy, and cost by determining which models are used to evaluate the event.  Available run modes include `precision_plus`, `precision`, `smart`, and `economy`.  Defaults to `smart`.',
        enum: ['precision_plus', 'precision', 'smart', 'economy'],
      },
      jq_filter: {
        type: 'string',
        title: 'jq Filter',
        description:
          'A jq filter to apply to the response to include certain fields. Consult the output schema in the tool description to see the fields that are available.\n\nFor example: to include only the `name` field in every object of a results array, you can provide ".results[].name".\n\nFor more information, see the [jq documentation](https://jqlang.org/manual/).',
      },
    },
    required: ['monitor_id', 'guardrail_metrics', 'model_input', 'model_output'],
  },
  annotations: {},
};

export const handler = async (client: Deeprails, args: Record<string, unknown> | undefined) => {
  const { monitor_id, jq_filter, ...body } = args as any;
  return asTextContentResult(
    await maybeFilter(jq_filter, await client.monitor.submitEvent(monitor_id, body)),
  );
};

export default { metadata, tool, handler };
